
## 关于异步编程

在学习nodejs的时候异步编程就是一个难点。但是好在已经有了许多的框架。
1：在处理异步编程中已经有哪些解决方案？
    * 事件发布/订阅模式 
    * Promise/Deferred模式
    * 流程控制模式
2：在nodejs中自己最喜欢的异步编程的处理方式？
    * 使用第三方的模块：async模块，感觉这种方式更加的直观，而且使用起来比较方便。很喜欢这种方式。这种方式是流程控制方式中的一种。
    
## AngularJS是如何实现异步？
* 通过$q.其中$q是对Promise异步编程模式的一个简化实现版本。
* 在异步编程中最核心的就是回调了。因为有了回调函数，所以才构成了异步编程。
     * 1：什么之后执行回调：请求成功或者失败的时候
     * 2：执行什么回调：
     * 3： 回调执行的时候传入什么参数。


## 异步编程的解决方案
 
### Promise/Deferred模式

![Image of Yaktocat](./img/async_promise.jpg)
* 什么是defer对象
  * defer对象（延期对象）。代表异步执行体。
* 什么是Promise对象？
  * promise是对异步编程的一种抽象。它是一个**代理对象**，代表一个必须进行异步处理的**函数返回的值**或**抛出的异常**。
  * promise对象（承诺对象）代表回调执行体。


* 从callback到promise
  * 经典的callback
```
readFile(function (err, data) {
  if (err) return console.error(err)
  console.log(data)
})
```

  * 使用promise
```
var promise = readFile()
promise.then(console.log, console.error)
```
* promise的链接及内嵌
  * then方法的返回值---还是一个promise对象（这个有点像jquery）
```
readFile()
  .then(readAnotherFile)
  .then(doSomethingElse)
  .then(...)
```
  * 在promise中使用内嵌
```
readFile()
  .then(function (data) {
    return readAnotherFile().then(function () {
      // do something with `data`
    })
  })
```


#### 延迟接口 | Deferred API
通过调用  $q.defer() 可以构建一个新的 deffered 实例。
deffered 对象用来将 Promise 实例与 标记任务状态(执行成功还是不成功)的 API 相关联。
**deffered 对象的方法**
  * resolve(value) ――传入 value 解决派生的 promise。 如果 value 是一个通过 $q.reject 构造的拒绝对象(rejection) , 该promise 将被拒绝。
  * reject(reason) ――拒绝派生的promise,并提供原因 。 这相当于通过 $q.reject构造的拒绝对象(rejection)作为参数传递给 resolve。
       在promise的.then(funciton(){})函数里面调用.作用是给.then()返回的下一个promise发送错误信息,并且给错误回调传入参数data
  * notify(value)  ――在 promise 执行的过程中提供状态更新。 这在 promise 被解决或拒绝之前可能会被多次调用。
  * $q.all([promise1,promise2,...]):
     当数组中的每个单一promise对象都收到了成功通知,这个新的promise对象也收到成功通知(回调参数是一个数组,数组中的各个值就是每个promise收到的data,注意顺序不是按照单个promise被通知的顺序,而是按照[promise1,promise2]这个数组里的顺序)
     当数组中的某个promise对象收到了失败通知,这个新的promise对象也收到失败通知,回调参数就是单个promise收到的失败通知的回调参数

**deffered 对象的属性**
  * promise C {Promise} ―― 与延迟(deferred)相关联的 promise 对象。

#### 承诺接口 | Promise API
当创建 deferred 实例时会创建一个新的 promise 对象,并可以通过  deferred.promise 得到该引用。
promise 对象的目的是在 deferred 任务完成时,允许感兴趣的部分取得其执行结果。
**promise 对象的方法**
* then(successCallback, errorCallback, notifyCallback) ――不管 promise 是被处理还是被拒绝, 一旦结果可用,then 就会尽快地异步调用 成功/错误 回调函数 只要结果是可用的。 调用回调函数时传递单个参数: 结果 或拒绝的理由。 此外,notify 回调可能被调用 0到多次,以提供 提供一个进度指示,之前承诺解决或拒绝。
           这个方法 返回一个新的promise 对象, 根据 successCallback , errorCallback的返回值进行解决或拒绝 。 它还通过 notifyCallback 方法的返回值进行通知。 promise 不能从notifyCallback方法得到解决或拒绝 。
* catch(errorCallback) ―― promise.then(null, errorCallback) 的快捷方式..
     如果defer发送的是失败通知，执行catch（）之后，下一个promise执行成功通知.下一个promise对象的形参就是catch回调的返回值.
     如果defer发送的是成功通知，跳过catch(),下一个promise执行成功通知，形参由defer传递。
* finally(callback) ――让你可以观察到一个 promise 是被执行还是被拒绝, 但这样做不用修改最后的 value值如果。 
                这可以用来做一些释放资源或者清理无用对象的工作,不管promise 被拒绝还是解决。 更多的信息请参阅完整文档规范.
             .finally也返回一个promise对象,和上面两个方法不同的是（不管通知成功与否，在finally中都会执行）,
             它为下一个promise对象发送的通知不一定是成功通知,而是传给finally的通知类型.
    如果defer发送的是失败通知,执行finally()之后，下一个promise执行失败通知，接收的参数是由defer得到的。
    如果defer发送的是成功的通知，执行完finally()之后。下一个promise执行成功通知，接收到的参数是上一个finnally的返回值。
            因为在 ES3版本的JavaScript中 finally 是一个保留字关键字,不能作为属性名,为了适配 IE8,您需要使用  promise['finally'](callback) 这种形式来调用该方法

###### 在promise中为什么有then？
* 前端程序员讨厌的代码
```javascript
fetchUser(function(user){
  fetchUserPermissons(user,function(permisson){
    fetchUserListData(user,permission,function(List){
    //对于你想要的数据进行处理
    })
  })
})
```
为了解决这个问题，promise方案提出了then的概念，在成功的时候执行一个函数，在出错的时候执行另外一个函数。这两个函数都可以进行链式
调用。
```
deferred.promise.then(fetchUser)
  .then(fetchUserPermissions)
  .then(fetchUserListData)
  .then(function(list){
  //处理数据列表
  },function(errorReason){
  //在任何一个地方发生错误，都可以在这里处理
  });
```
#### Promise/Deferred模式的优点和缺点
* 优点：Promise/Deferred模式的API接口和抽象模型都十分的简洁。
* 缺点：对于不同的场景，都需要去封装和改造Deferred部分。然后才能得到简洁的接口。

在CommonJS草案中已经抽象出了Promise/A、Promise/B，Promise/C,Promise/D这四种典型的异步Promise/Deferred模型。

#### 简单的例子
在html页面中
```
<!DOCTYPE html>
<html ng-app="Async">
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
    <script src="../lib/angular.min.js"></script>
    <script src="controllist.js"></script>
</head>
<body>
<div ng-controller="promise">
</div>
</body>
</html>
```
在js代码中
```
var HttpREST=angular.module('Async',[]);
//基本例子
HttpREST.controller('promise',function($q,$http){
    /**
     * 1：创建一个defer对象
     * 2：创建一个defer对象对应的promise对象
     * 3：promise对象定义了成功回调函数，定义了失败回调函数
     * 4：对于promise发起通知
     * */
        //创建defer对象
    var defer=$q.defer();
    // 创建defer对象对应的promise对象
    var promise=defer.promise;
    //定义了成功之后的执行，和失败之后的执行
    promise.then(function(data){
        console.log('成功'+data);
    },function(data){
        console.log('失败'+data);
    });
    //对于promise发起通知
    defer.resolve('code_buny');
});
```
![Image of Yaktocat](./img/aync_$q_1.jpg)
当调用defer.resolve('code_buny')的时候执行promise中成功的时候的回到函数，resolve函数中的参数就是回调成功执行的时候的参数。

#### 简单的例子--单次调用
html页面
```
<!DOCTYPE html>
<html ng-app="Async">
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
    <script src="../../lib/angular.min.js"></script>
    <script src="../controllist.js"></script>
</head>
<body>
<div ng-controller="promise">
    <h3 ng-bind="name"></h3>
</div>
</body>
</html>
```
控制器中的js
```
var httpREST=angular.module('Async',[]);
//defer.resolve()  defer.reject()  defer.notify()
httpREST.controller('promise',function($q,$http,$scope){
    /**
     * 1:创建一个defer对象
     * 2：创建一个promise对象
     * 3：在promise中定义回调函数，成功的时候执行什么回调函数，失败的时候执行什么回调函数，度回函数
     * 4：定义一个$http的get请求。这个请求在成功的时候调用defer.reolve(res.data),在失败的时候调用defer.reject(res.data)
     * */

    var defer=$q.defer();
    var promise=defer.promise;
    promise.then(function(data){
        $scope.name='成功'+data;
    },function(data){
        $scope.name='失败'+data;
    },function(data){
        $scope.name='进度'+data;
    });

    $http({
        method:'GET',
        url:'/name'
    }).then(function(res){
        defer.resolve(res.data);
    },function(res){

        defer.reject(res.data);
    });

});

```
nodejs中的js
```
/**
 * Created by John on 2015-10-02.
 */
var express = require('express');
var url = require('url');
var path=require('path');
var swig=require('swig');
var app = express();
app.use(express.static(path.join(__dirname, 'public')));
//设置模块引擎
app.engine('html',swig.renderFile);
app.set('views', path.join(__dirname, 'views'));
app.set('view engine', 'html');

app.get('/name1',function(req,res){
    setTimeout(function(){res.send('ok')},2000)
});
app.get('/',function(req,res){
    res.render('index');
});

app.listen(3000);
console.log("Server runing at port: " + '3000' + ".");
```
1:如果后台没有**/name**的处理的时候得到的结果是
![Image of Yaktocat](./img/aync_$q_2.jpg)

2：如果后台有**/name**的处理的时候得到的结果是
![Image of Yaktocat](./img/aync_$q_3.jpg)

#### 简单的例子--多次调用
html页面中
```
```
在js中
```
var httpREST=angular.module('Async',[]);
//defer.resolve()  defer.reject()  defer.notify()
httpREST.controller('promise',function($q,$http,$scope){
    /**
     * 1:创建一个defer对象
     * 2：创建一个promise对象
     * 3：在promise中定义回调函数，成功的时候执行什么回调函数，失败的时候执行什么回调函数，度回函数
     * 4：定义一个$http的get请求。这个请求在成功的时候调用defer.reolve(res.data),在失败的时候调用defer.reject(res.data)
     * */

    var defer=$q.defer();
    var promise=defer.promise;
    promise.then(function(data){
        $scope.name='成功'+data;
        //这里的返回值传递给下一个then方法的形参
     //   return 'hellow 2';
    }).then(function(data){
        $scope.name2='成功2'+data;
    },function(data){
        //任何一个步骤中发生错误，都可以在这里处理
        $scope.name2="错误2"+data;
    });

    $http({
        method:'GET',
        url:'/name'
    }).then(function(res){
        defer.resolve(res.data);
    },function(res){

        defer.reject(res.data);
    });

});

```
在nodejs中
```
/**
 * Created by John on 2015-10-02.
 */
var express = require('express');
var url = require('url');
var path=require('path');
var swig=require('swig');
var app = express();
app.use(express.static(path.join(__dirname, 'public')));
//设置模块引擎
app.engine('html',swig.renderFile);
app.set('views', path.join(__dirname, 'views'));
app.set('view engine', 'html');

app.get('/name',function(req,res){
    setTimeout(function(){res.send('ok')},2000)
});
app.get('/',function(req,res){
    res.render('index');
});

app.listen(3000);
console.log("Server runing at port: " + '3000' + ".");
```



1：如果我没有在前面的then函数中return 一个值的话，后面的then函数中参数将没有
有return值的时候
![Image of Yaktocat](./img/aync_$q_4.jpg)
没有return值的时候
![Image of Yaktocat](./img/aync_$q_5.jpg)
2：任何一个步骤中发生错误，都可以在最后一个then方法的错误处理函数中进行处理。



    